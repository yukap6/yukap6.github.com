# 从零开始实现一个微前端框架[1]——理论基础

![](http://www.iseeit.cn/wp-content/uploads/2020/10/WechatIMG473.jpeg)

环境要求：
1. 前端采用哈希路由（重点关注）；
2. `React` 项目；

## 动机

原始需求：
1. 经过10+人2+年的迭代，基于 `React` 的 SPA 项目越来越大，本地开发、打包编译都极其耗时，劳神劳心；
2. 老模块要维持对低版本浏览器 IE8 的支持；
3. 新模块可以升级到最新版 `React(v16)` 并且不再支持 IE10- 浏览器（意味着多个 `React` 版本会并存）；

既然是巨无霸项目，第一反应就是采用微前端拆分项目，主要基于以下考虑：
* 项目之间路由切换时，按需加载对应项目资源即可，不会出现传统页面切换时的白屏问题，体验更丝滑；
* 只需维护一套公共的 HTML 模板；
* 开发、打包及编译更快（因为项目更小，消耗更少资源）；

如何落地微前端，有很多思路，这里就不一一列举了，业界也有比较成熟的微前端框架，本以为可以“站在巨人的肩膀上”看风景，只可惜巨人说：“IE8 是什么，老子不认识它。”（为了使用新特性，都默契的选择了放弃对低版本浏览器的支持）。

既然如此，我还能说什么呢？（总得有人独自面对 IE8 😂）

## 实现

想象一下，一个微前端框架运行的时候，大概是这样的：访问到A项目的某个路由时，加载A项目的对应文件进行渲染；切换到B项目的某个路由时，先卸载A项目，然后再去加载B项目的对应文件并进行渲染；之后一直循环往复。

从以上流程中，可以梳理出几个重要*节点*：
* 管理不同项目的路由，并根据不同路由去加载对应项目文件资源；
* 项目加载及渲染；
* 项目卸载（环境隔离）；

针对整个流程中的关键节点，实现思路大致是：
1. 监听 `window` 的全局 `hashchange` 事件，当哈希路由变化时，根据不同路由去加载对应项目文件资源；
2. 将子项目打包为 `UMD` 格式的文件，通过 `script` 标签的形式加载项目文件后，对外暴露一个标准的 `React` 组件类；
3. 子项目入口文件加载完成后，拿到暴露出来的标准 `React` 组件，使用 `ReactDOM.render()` 方法进行渲染 ；
4. 卸载项目的时候，首先使用 `ReactDOM.unmountComponentAtNode(node)` 卸载当前项目，然后再删除掉当前项目引入的所有外部资源，以达到环境清理的目的；

思路有了之后，接下来继续实现每一步中的细节即可。

#### 第一步：全局路由管理，判断子项目的加载和卸载时机

这块相对简单，因为项目中统一采用了哈希路由，所以只需要在全局框架中监听浏览器的 `hashchange` 事件即可判断当前应该激活哪个项目，具体步骤是：
1. 框架加载就绪后立刻监听 `window` 的 `hashchange` 事件；
2. 当哈希路由变化时，根据当前路由来判断需要激活哪个子项目（以及卸载当前已经加载的子项目）；

> 这里需要注意的是，第一次加载框架时，需要默认执行一次哈希路由分析，来确定初始化时应该加载哪个子项目（`hashchange` 事件的监听只有在后续路由切换时会生效）。

#### 第二步：子项目打包为 UMD 格式文件，统一输出 React 组件类

`webpack.config.js` 的核心配置如下

```
output: {
  libraryTarget: 'umd',
},
```

此时，子项目打包后的入口文件对外暴露的是一个以自己项目名称为变量名的对象，当子项目的入口文件加载完成时，即可得到 `window[项目名称].default` 暴露出来的标准 `React` 组件类，这个组件类是可以用于直接渲染和卸载的。

> 关于 React 项目打包为 umd 格式后，会输出一个 `window[项目名称].default` 的标准 React 组件，具体细节可以阅读这篇文章 [从 `hello world` 示例解析 `webpack` 打包后的 `react` 项目代码运行原理](http://www.iseeit.cn/index.php/2020/05/14/webpack-react-babel-hello-world/)

#### 第三步：加载 & 渲染子项目

1. 通过 `script` 标签动态加载子项目的入口文件；
2. 拿到入口文件暴露出来的对象，用来渲染;

这里的核心逻辑是，子项目入口文件加载完成时，会作为一个立即执行函数执行；执行完成后，会对外暴露一个 `window[项目名称]` 的对象；而该对象就是一个标准的 React 组件，此时就可以用 `ReactDOM.render(React.createElement(window[项目名称].default), document.getElementById('app'))` 的方式渲染子项目，到此为止，子项目的加载和渲染就完成了。

#### 第四步：卸载子项目 & 环境隔离

1. 卸载当前子项目，核心实现是 `ReactDOM.unmountComponentAtNode(node)`，即标准的 `React` 组件卸载。
2. 删除上一个项目引入的所有外部资源；
3. 加载下一个子项目的入口文件并渲染；

这里着重介绍一下如何删除上一个子项目的所有资源，具体做法也很简单，核心工作就是“提前标记”。当主框架加载完成后，立刻对已加载的所有资源进行标记（加上特殊的属性标记），这样当某个子项目加载完成后，没有被标记的资源就是该子项目的所有相关资源了。当准备切换到下一个子项目之前，先对未标记的资源（当前子项目的资源）进行移除操作即可。

## 总结一下

至此，一个微前端框架的核心思路已经成型，下一篇文章会继续讲完整的代码实现，敬请期待。

（以上）
