# HTTP 系列之 状态码

### 基本介绍

状态码由三位整数组成，表示服务器尽可能理解和完成客户端请求时的响应状态。

HTTP 状态码是可扩展的。客户端不需要识别所有已声明的状态码，当然如果能够做到这一点就更完美了。但是呢，客户端必须识别状态码的任何一个基本类别，也就是三位整数的第一位（用以表明状态码基本类型）。对于不能识别的状态码，则按照 x00 来对待（x 保持对应基本类型不变），此外，不能识别的状态码对应的数据也是不允许缓存的。

例如，如果客户端接收到一个不能识别的 471 状态码，则客户端就可以假定是请求数据错误，并将该状态码当做 400 状态码来对待。通常情况下，服务器端响应会包含对应状态的解释信息。

状态码的第一位数字用来确定响应类型。另外两位数字暂时还未进行分类。目前为止，第一位数字有5种取值：

* 1xx (信息)：请求已收到，需要请求者继续执行操作
* 2xx (成功)：请求已成功收到理解并接受
* 3xx (跳转)：需要进一步的操作以完成请求
* 4xx (客户端错误)：客户端请求包含语法错误或请求无法完成
* 5xx (服务器错误)：服务器在处理请求的过程中发生了错误

### 状态码一览表

已知状态码分别在 [RFC 7231 第六章](https://tools.ietf.org/html/rfc7231#section-6)、[RFC 7232 第四章](https://tools.ietf.org/html/rfc7232#section-4)、[RFC 7233 第四章](https://tools.ietf.org/html/rfc7233#section-4)以及 [RFC 7235 第三章](https://tools.ietf.org/html/rfc7235#section-3) 中进行了定义。下表中的 `描述短语`(reason phrases) 列只是建议值，在不影响协议的前提下，可以使用本地的同等描述替换。

部分状态码对应的数据是可以缓存（比如：200， 203， 204， 206， 300， 301， 404， 405， 410， 414， 和 501）并再次使用的（在一定[缓存规则控制](https://tools.ietf.org/html/rfc7234)下）；剩余的状态码对应响应默认都是不可缓存的。

| 状态码        | 描述短语 | 文档位置           |
| ------------- | :-------- |:-------------|
| 100      | Continue | [RFC 7231 6.2.1](https://tools.ietf.org/html/rfc7231#section-6.2.1) |
| 101 | Switching Protocols | [RFC 7231 6.2.2](https://tools.ietf.org/html/rfc7231#section-6.2.2) |
| 200 | OK | [RFC 7231 6.3.1](https://tools.ietf.org/html/rfc7231#section-6.3.1) |
| 201 | Created | [RFC 7231 6.3.2](https://tools.ietf.org/html/rfc7231#section-6.3.2) |
| 202 | Accepted | [RFC 7231 6.3.3](https://tools.ietf.org/html/rfc7231#section-6.3.3) |
| 203 | Non-Authoritative Information | [RFC 7231 6.3.4](https://tools.ietf.org/html/rfc7231#section-6.3.4) |
| 204 | No Content | [RFC 7231 6.3.5](https://tools.ietf.org/html/rfc7231#section-6.3.5) |
| 205 | Reset Content | [RFC 7231 6.3.6](https://tools.ietf.org/html/rfc7231#section-6.3.6) |
| 206 | Partial Content | [RFC 7233 4.1](https://tools.ietf.org/html/rfc7233#section-4.1) |
| 300 | Multiple Choices | [RFC 7231 6.4.1](https://tools.ietf.org/html/rfc7231#section-6.4.1) |
| 301 | Moved Permanently | [RFC 7231 6.4.2](https://tools.ietf.org/html/rfc7231#section-6.4.2) |
| 302 | Found | [RFC 7231 6.4.3](https://tools.ietf.org/html/rfc7231#section-6.4.3) |
| 303 | See Other | [RFC 7231 6.4.4](https://tools.ietf.org/html/rfc7231#section-6.4.4) |
| 304 | Not Modified | [RFC 7232 4.1](https://tools.ietf.org/html/rfc7232#section-4.1) |
| 305 | Use Proxy | [RFC 7231 6.4.5](https://tools.ietf.org/html/rfc7231#section-6.4.5) |
| 307 | Temporary Redirect | [RFC 7231 6.4.](https://tools.ietf.org/html/rfc7231#section-6.4.7) |
| 400 | Bad Request | [RFC 7231 6.5.1](https://tools.ietf.org/html/rfc7231#section-6.5.1) |
| 401 | Unauthorized | [RFC 7235 3.1](https://tools.ietf.org/html/rfc7235#section-3.1) |
| 402 | Payment Required | [RFC 7231 6.5.2](https://tools.ietf.org/html/rfc7231#section-6.5.2) |
| 403 | Forbidden | [RFC 7231 6.5.3](https://tools.ietf.org/html/rfc7231#section-6.5.3) |
| 404 | Not Found | [RFC 7231 6.5.4](https://tools.ietf.org/html/rfc7231#section-6.5.4) |
| 405 | Method Not Allowed | [RFC 7231 6.5.5](https://tools.ietf.org/html/rfc7231#section-6.5.5) |
| 406 | Not Acceptable | [RFC 7231 6.5.6](https://tools.ietf.org/html/rfc7231#section-6.5.6) |
| 407 | Proxy Authentication Required | [RFC 7235 3.2](https://tools.ietf.org/html/rfc7235#section-3.2) |
| 408 | Request Timeout | [RFC 7231 6.5.7](https://tools.ietf.org/html/rfc7231#section-6.5.7) |
| 409 | Conflict | [RFC 7231 6.5.8](https://tools.ietf.org/html/rfc7231#section-6.5.8) |
| 410 | Gone | [RFC 7231 6.5.9](https://tools.ietf.org/html/rfc7231#section-6.5.9) |
| 411 | Length Required | [RFC 7231 6.5.10](https://tools.ietf.org/html/rfc7231#section-6.5.10) |
| 412 | Precondition Failed  | [RFC 7232 4.2](https://tools.ietf.org/html/rfc7232#section-4.2) |
| 413 | Payload Too Large | [RFC 7231 6.5.11](https://tools.ietf.org/html/rfc7231#section-6.5.11) |
| 414 | URI Too Long | [RFC 7231 6.5.12](https://tools.ietf.org/html/rfc7231#section-6.5.12) |
| 415 | Unsupported Media Type | [RFC 7231 6.5.13](https://tools.ietf.org/html/rfc7231#section-6.5.13) |
| 416 | Range Not Satisfiable | [RFC 7233 4.4](https://tools.ietf.org/html/rfc7233#section-4.4) |
| 417 | Expectation Failed | [RFC 7231 6.5.14](https://tools.ietf.org/html/rfc7231#section-6.5.14) |
| 426 | Upgrade Required | [RFC 7231](https://tools.ietf.org/html/rfc7231#section-6.5.15) |
| 500 | Internal Server Error | [RFC 7231 6.6.1](https://tools.ietf.org/html/rfc7231#section-6.6.1) |
| 501 | Not Implemented | [RFC 7231 6.6.2](https://tools.ietf.org/html/rfc7231#section-6.6.2) |
| 502 | Bad Gateway | [RFC 7231 6.6.3](https://tools.ietf.org/html/rfc7231#section-6.6.3) |
| 503 | Service Unavailable | [RFC 7231 6.6.4](https://tools.ietf.org/html/rfc7231#section-6.6.4) |
| 504 | Gateway Timeout | [RFC 7231 6.6.5](https://tools.ietf.org/html/rfc7231#section-6.6.5) |
| 505 | HTTP Version Not Supported | [RFC 7231 6.6.6](https://tools.ietf.org/html/rfc7231#section-6.6.6) |

注意，当前列表并没有详尽的列出所有状态码（其他规格里定义的扩展状态码不包含在此列表）。完整的状态码列表是由 IANA 维护的。[详见 RFC 7231 8.2](https://tools.ietf.org/html/rfc7231#section-8.2)。

### 详细解释

#### 1xx 信息（Informational）

1xx（信息）类状态码表示本次响应处于通信连接临时响应阶段，或者请求操作处于完成并发送最终响应之前的前置阶段。状态行（status-line）后的第一个空行用来结束本次响应（空行是头部信息段落结束信号）。由于 HTTP/1.0 没有规定任何 1xx 类型的状态码，所以当客户端的协议类型是 HTTP/1.0 时，服务器不允许返回任何 1xx 类型的状态码。

即使客户端不期望接收 1xx 类型的状态码，也必须能够解析一个或更多 1xx 类型的状态码，用以接收最终响应之前的前置信息。用户代理则可以选择忽略某些非期望的 1xx 类型状态码。

代理服务器必须继续推送 1xx 类型的响应，除非代理服务器本身请求生成 1xx 类型的响应。比如：当代理服务器转发一个请求时，添加了元信息 "Expect: 100-continue"，则此时可以不继续转发原始的 100 响应。

| 状态码        | 描述短语 | 描述           |
| ------------- | :-------- |:-------------|
| 100      | Continue | 继续请求。100 状态码表示初始化的请求数据已被接收，且仍未被拒绝。当服务器完全接收到请求数据之后将会尝试去发送一个最终响应给客户端。<br><br> 当一个请求包含 `100-continue` 的请求头信息时，100 类型的响应则表明服务器期望继续接收请求的负载体（paypload body），详情参照 [RFC 7231 5.1.1](https://tools.ietf.org/html/rfc7231#section-5.1.1) 。<br><br> 如果请求没有包含任何期望 `100-continue` 的头信息，则客户端可以简单抛弃接收到的 100 过渡响应即可。 |
| 101 | Switching Protocols | 101 状态码表明服务器理解并将继续遵守客户端升级协议的请求，通过升级头部元信息([RFC 7230 6.7](https://tools.ietf.org/html/rfc7230#section-6.7))来更换在此连接上使用的应用程序协议。服务器必须在响应中生成一个升级头信息，表明在发送空行结束 101 响应之后将立即切换到目标协议。<br><br>     服务器同意升级协议的前提是：目标协议是有利的（更好、更新）。比如：升级到较新的 HTTP 协议相比旧的协议而言就是有利的；或者切换到一个实时且同步的协议以传送利用此类特性的资源。|

#### 2xx 成功（Successful）

2xx 状态码表示客户端请求已被服务器成功接收、理解并接受。

| 状态码        | 描述短语 | 描述           |
| ------------- | :------- |:-------------|
| 200      | OK | 成功。200 状态码表示请求成功。200 响应的内容取决于请求的方法。本规格文件定义的请求方法对应的响应负载含义总结如下：<br><br> GET，目标资源的表示<br>HEAD，同 GET，但是没有表示数据。<br> POST，表示请求操作的状态或从请求操作中获得的结果<br> PUT， DELETE，操作状态的表示<br> OPTIONS 通信选项的表示<br> TRACE，由终端服务器接收的请求消息的表示<br><br>尽管原始服务器可能会生成一个长度为零的负载，但是一般情况下，一个链接总是会有对应的响应消息体返回。如果没有请求任何内容，则服务器可以用204状态码替代200状态码。对于一次网络连接来说，没有负载是被允许的，比如成功结果是一个立即开始的通道的情况。<br><br>除了 [RFC 7234 4.2.2](https://tools.ietf.org/html/rfc7234#section-4.2.2) 定义的特殊缓存规则控制情况外，一个200状态的响应默认是可缓存的。 |
| 201 | Created | 创建成功。201状态码表明请求已被成功处理，并且有相应的一个或多个资源被创建。请求创建的基本资源URI要么在头部信息里返回，要么就是当前有效请求的URI。<br><br> 201状态的响应负载多数情况下描述并链接到请求创建的资源上。[RFC 7231 7.2](https://tools.ietf.org/html/rfc7231#section-7.2) 详细讨论了一个201状态的响应头信息中验证字段的含义，比如 `ETag` 和 `Last-Modified` |
| 202 | Accepted | 已接受。202状态码表示请求已经被接受并开始处理，但是处理还未完成。请求可能会被成功处理，也可能因为处理时占用太多资源而导致被拒绝。在HTTP协议中，对于一个异步请求，没有措施去重新发送一个响应状态码。<br><br>202状态的响应是有意不表明结果的。目的是为了处理一些无需客户端代理一直和服务器保持连接直到处理结束的情况（比如一个每天只需要执行一次的批处理任务）。此响应发送的信息应该描述请求处理的当前状态，并指向(或嵌入)可以让客户端来预估请求何时实现的状态监视器。 |
| 203 | Non-Authoritative Information | 非授权信息。203(非授权信息)状态代码表明请求成功，但是返回的有效负载由转换代理 [RFC 7230 5.7.2](https://tools.ietf.org/html/rfc7230#section-5.7.2) 修改了源服务器的200(OK)响应。该状态码允许代理在应用转换时通知接收方，因为这些信息可能会影响以后关于内容的决策。例如，当验证一份内容的缓存是否可用时，可能需要限制请求是基于相同的请求路径(通过相同的代理)。<br><br> 203响应类似于[214](https://tools.ietf.org/html/rfc7234#section-5.5)转换应用的警告代码，而214的优点是可以适用于任何状态的响应。<br><br> 默认情况下，203响应是可缓存的; 除非方法定义或显式的缓存控制(参见 [RFC 7234 4.2.2](https://tools.ietf.org/html/rfc7234#section-4.2.2) )。 |
| 204 | No Content | 无响应内容。204状态码表示服务器已经成功处理了请求，并且没有任何负载消息体需要发送。*响应头字段中的元信息引用目标资源及其请求操作应用之后的选择描述。* <br><br> 例如：如果客户端发起一个 PUT 类型的请求，然后接收到一个包含 ETag 头部字段的204响应，则表示 PUT 请求成功处理并且 ETag 的值包含目标资源呈现的实体标记。<br><br>204响应允许服务器指示该操作已经成功地应用到目标资源，同时暗示用户代理不需要 traverse away from 其当前“文档视图”(如果有的话)。<br><br> 例如，一个204状态码通常用于与“保存”操作对应的文档编辑接口，这样保存的文档仍然可以用于用户进行编辑。它还经常被用于希望实现自动化数据传输的接口，例如在分布式版本控制系统中。<br><br> 在头字段之后，第一个空行终止了一个204响应，因为它不能包含消息体。<br><br> 默认情况下，204响应是可缓存的; 除非方法定义或显式的缓存控制(参见[RFC7234](https://tools.ietf.org/html/rfc7234#section-4.2.2)的第4.2.2节)。 |
| 205 | Reset Content | 重置内容。205响应表示服务器已经满足了客户端请求，并且希望客户端将发起该次请求的“文档视图”重置为从原始服务器获取到的状态。<br><br> 这种响应是为了支持通用的数据录入案例， 比如，用户在可访问的空间进行数据录入(表单、记事本、canvas 等)或维护， 并且可以发起请求以提交录入的数据，当收到205响应之后，就可以重置数据输入机制为下一次录入做好准备， 这样用户可以很容易地启动另一个输入操作。<br><br> 由于205个状态代码意味着不会提供额外的内容，因此服务器不能在205响应中生成有效负载。换句话说，服务器返回一个205响应必须满足下面条件中的一个：<br> a)：在头部字段中包含 `Content-Length`，并且取值为0，表示响应消息体长度为零。<br> b)：为响应指定一个零长度的有效负载，包括一个具有分块值的传输编码头字段和一个由零长度的单个块组成的消息体。<br> c)：在发送空行终止响应的头部后，立即关闭连接。 |
| 206 | Partial Content | 部分内容。GET 请求的部分资源已被服务器正确处理。 |

#### 3xx 重定向

3xx(重定向)类状态码表示，为了完成请求，用户代理需要采取进一步的操作。如果提供了Location头字段([第7.1.2节](https://tools.ietf.org/html/rfc7231#section-7.1.2))，则用户代理应该自动将其请求重定向到Location字段值引用的URI，即使不理解特定的状态码。由于用户可能不希望重定向一个不安全的请求，所以自动重定向需要谨慎地处理不确定是否安全的方法，如第[4.2.1](https://tools.ietf.org/html/rfc7231#section-4.2.1)节中定义的那样。

有以下几种重定向类型：

1. 重定向表示资源可能在不同的URI上是可用的，由Location字段提供，如状态码301(永久移动)、302(找到)和307(临时重定向)。
2. 重定向提供了一种匹配资源的选择，每一个都能代表原始请求目标，比如300(多个选择)状态码。
3. 重定向到不同的资源，由Location字段标识，可以表示对请求的间接响应，如303(参见其他)状态码。
4. 重定向到先前缓存的结果，如304(未修改)状态码。

注意：在HTTP/1.0中，状态码301(永久移动)和302(找到)被定义为第一类重定向([RFC1945，第9.3节](https://tools.ietf.org/html/rfc1945#section-9.3))。早期的用户代理，对于是否应该在重定向到目标时保持和原始请求相同的请求方法，还是将请求重写为 GET 方法是存在分歧的。虽然HTTP最初定义了301和302的前语义(以匹配其在CERN的原始实现)，并定义了303(参见其他)，以匹配后者的语义，但常见的实践也逐渐在301和302的语义上趋于一致。HTTP/1.1的第一个修订增加了307(临时重定向)，以表示规范语义，而不受不同实践的影响。经过10年后，大多数用户代理仍然会重写301和302的请求方法；因此，当原始请求的方法是 POST 时，该规范统一了行为表现。

客户端应该检测并干预周期性的重定向(即:“无限”重定向循环)

注意:本规范的早期版本建议最多使用5个重定向([RFC2068，第10.3节](https://tools.ietf.org/html/rfc2068#section-10.3))。开发人员需要意识到一些客户端可能会实现这样一个固定的限制。


| 状态码 | 描述短语 | 描述 |
| --- | --- | --- |
| 300 | Multiple Choices | 多种选择。300(多个选择)状态码表示目标资源有多个呈现，每个都有自己的更具体的标识符，和选择的信息被提供，以便用户(或用户代理)可以通过重定向请求的一个或多个标识符选择首选呈现。换句话说，服务器希望用户代理参与反应性协商，以选择最适合其需要的呈现形式（[3.4](https://tools.ietf.org/html/rfc7231#section-3.4)）。 <br><br> 如果服务器有一个首选的选择，那么服务器应该生成一个 Location 头字段，其中包含首选的URI引用。用户代理可以使用 Location 字段值自动重定向。 <br><br> 除了HEAD以外的请求方法，服务器应该在300个响应中生成一个有效负载，其中包含一个表示元数据和URI引用的列表，用户或用户代理可以从中选择最合适的一个。 如果用户代理了解所提供的媒体类型，则可以自动从该列表中进行选择。这个规范没有定义自动选择的特定格式，因为HTTP试图与它的有效负载的定义保持正交。在实践中，通过共享的设计或内容协商，或者在一些普遍接受的超文本格式中，用户代理可以接受一些容易解析的格式。 <br><br> 默认情况下，300响应是可缓存的; 除非方法定义或显式的缓存控制(参见[RFC7234](https://tools.ietf.org/html/rfc7234#section-4.2.2)的第4.2.2节)。<br><br> 对于300个状态代码的原始建议定义了URI头字段，它提供了一个备选表示列表，这样它就可以用于200、300和406响应，并在对HEAD方法的响应中使用。然而，由于缺乏对语法的部署和不一致，导致URI和Alternates(后来的建议)被从这个规范中删除。可以使用一组链接头字段(RFC5988)来传递列表，每个字段都有“alternate”的关系，尽管部署是一个先有鸡还是先有蛋的问题。 |
| 301 | Moved Permanently | 永久移动。301(永久移动)状态码表示目标资源已经被分配了一个新的永久URI，并且任何将来对该资源的引用都应该使用其中一个URI(s)。具有链接编辑功能的客户端应该自动将对有效请求URI的引用重新链接到服务器发送的一个或多个新引用中。<br><br> 服务器应该在响应中生成一个 Location 头字段，其中包含新的永久URI的首选引用。用户代理可以使用 Location 字段值自动重定向。服务器的响应负载通常包含一个附有指向新 URL(s) 超链接的短超文本记录。<br><br> 注意：出于历史原因，用户代理在后续请求中可能会从 POST 方法改为 GET 方法。如果这种表现是不符合需求，则可以使用307(临时重定向)状态码。<br><br> 默认情况下，301响应是可缓存的; 除非方法定义或显式的缓存控制(参见[RFC7234](https://tools.ietf.org/html/rfc7234#section-4.2.2)的第4.2.2节)。|
| 302 | Found | 临时移动。302(找到)状态码表示目标资源暂时驻留在不同的 URI 下。由于重定向可能会在某些情况下发生更改，因此客户端应该继续使用有效的请求 URI 来处理将来的请求。<br><br> 服务器应该在响应中生成一个 Location 头字段，其中包含对于不同 URI 的 URI 引用。用户代理可以使用 Location 字段值自动重定向。服务器的响应负载通常应该包含一个超链接文本来指向不同的 URL(s)。<br><br> 注意：出于历史原因，用户代理在后续请求中可能会从 POST 方法改为 GET 方法。如果这种表现是不符合需求，则可以使用307(临时重定向)状态码。|
| 303 | See Other | 查看其它。303(查看其他)状态码表示，服务器正在将用户代理重定向到另一个资源，如 Location 头字段中的 URI 所指示的，目的是提供对原始请求的间接响应。用户代理可以执行针对该URI的检索请求(如果使用HTTP)，也可以被重定向，并将最终结果作为对原始请求的应答。注意，Location 头字段中的新 URI 并不等同于有效的请求 URI。<br><br> 该状态码可以应用到任何一个 HTTP 方法上。它主要用于允许 POST 操作的输出将用户代理重定向到所选的资源，因为这样做提供了与 POST 响应相对应的信息，该表单可以独立地标识、添加书签和缓存，独立于原始请求。<br><br> 对GET请求的303响应表明源服务器没有可以通过 HTTP 传输的目标资源的表示。但是，Location 字段值是指对目标资源进行描述性的资源，例如，对其他资源进行检索请求可能会导致对接收者有用的表示，而不意味着它代表原始的目标资源。请注意，对于可以表示的问题的答案，什么表示是适当的，以及什么可能是有用的描述超出了HTTP的范围。<br><br> 除了对HEAD请求的响应之外，303响应的表示应该包含一个短的超文本，并且在 Location 头字段中提供相同 URI 引用的超链接。 |
| 304 | Not Modified | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源。 |
| 305 | Use Proxy | 使用代理。已废弃。 |
| 306 | Unused | 未使用。未使用，状态码保留。 |
| 307 | Temporary Redirect | 临时重定向。307(临时重定向)状态码表示目标资源暂时驻留在不同的 URI 下，如果用户代理执行自动重定向到该 URI，则不能更改请求方法。由于重定向可以随时间变化，客户端应该继续使用原始有效请求 URI 来处理将来的请求。<br><br> 服务器应该在响应中生成一个 Location 头字段，其中包含不同 URI 的 URI 引用。用户代理可以使用 Location 字段值自动重定向。服务器的响应负载通常应该包含一个超链接文本来指向不同的 URL(s)。<br><br> 注意：此状态代码类似于302(临时重定向)，只是不允许从把请求方法从 POST 更改为 GET。此规范定义了301的对等物。不过，永久地移动)([RFC7238](https://tools.ietf.org/html/rfc7238))，为这个目的定义了状态代码308(永久重定向)。|

#### 4xx 客户端错误

4xx 类型的状态码表示客户端似乎出现了错误。除了响应HEAD请求时，服务器应该发送包含错误情况说明的表示，以及它是临时的还是永久的状态。这些状态码适用于任何请求方法。用户代理应该向用户显示任何包含的表示。


| 状态码 | 描述短语 | 描述 |
| --- | --- | --- |
| 400 | Bad Request | 错误请求。400(错误请求)状态码表示服务器不能或不会处理请求，因为客户端请求包含错误（比如：格式错误的请求语法，无效的请求消息框架，或欺骗性请求路由。）。|
| 401 | Unauthorized | 请求要求用户的身份认证。 |
| 402 | Payment Required | 保留，未来使用。 |
| 403 | Forbidden | 禁用。403(禁用)状态代码表示服务器理解请求，但拒绝授权。服务器如果想要公开请求被拒绝的原因，那么就应该在响应的有效负载中进行说明（如果可以的话）。 <br><br> 如果请求中提供了身份验证凭证，则服务器认为它们不足以授予访问权限。客户端不应自动使用相同凭据发起重复请求。客户端可以使用新的或不同的凭证重复请求。但是，出于与凭证无关的原因，可能会禁止请求。<br><br> 如果源服务器希望隐藏被拒绝访问的当前资源，则应该使用 404(Not Found) 状态码。 |
| 404 | Not Found | 未找到。404(未找到)状态码表明源服务器没有找到目标资源的当前表示，或者不愿意透露该资源的存在。404状态码不能表示这种资源缺失是临时的还是永久的；如果源服务器通过某种可配置的方法知道该条件可能是永久性的，那么410(消失)状态码将优于404。<br><br> 默认情况下，404响应是可缓存的; 除非方法定义或显式的缓存控制(参见[RFC7234](https://tools.ietf.org/html/rfc7234#section-4.2.2)的第4.2.2节)。 |
| 405 | Method Not Allowed | 方法不允许。405(方法不允许)状态码表示源服务器理解在请求行中接收的方法，但目标资源不支持。源服务器必须在405响应中生成一个允许头字段，其中包含目标资源当前支持的方法的列表。<br><br> 默认情况下，405响应是可缓存的; 除非方法定义或显式的缓存控制(参见[RFC7234](https://tools.ietf.org/html/rfc7234#section-4.2.2)的第4.2.2节)。 |
| 406 | Not Acceptable | 不可接受。406(不可接受的)状态码表示，根据请求中的主动协商头字段(第[5.3](https://tools.ietf.org/html/rfc7231#section-5.3)节)，目标资源没有一个可以被用户代理接受的当前表示，同时服务器不愿意提供默认的表示。<br><br> 服务器应该生成一个有效负载，其中包含可用的表示特征列表和相应的资源标识符，用户或用户代理可以从中选择最合适的标识符。用户代理可以自动从该列表中选择最合适的选项。然而，本规范没有定义任何自动选择的标准，如第[6.4.1](https://tools.ietf.org/html/rfc7231#section-6.4.1)节所述。|
| 407 | Proxy Authentication Required | 请求需要代理授权。请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权。 |
| 408 | Request Timeout | 请求超时。408(请求超时)状态码表明服务器在准备等待的时间内没有收到完整的请求消息。服务器应该在响应中发送“close”连接选项([RFC7230的第6.1节](https://tools.ietf.org/html/rfc7230#section-6.1))，因为408意味着服务器决定关闭连接，而不是继续等待。如果客户端在传输中有一个未完成的请求，客户端可能会在新的连接上重复该请求。 |
| 409 | Conflict | 冲突。409(冲突)状态码表示由于与目标资源当前状态的冲突，请求无法完成。此代码用于客户端可能能够解决冲突并重新提交请求的情况。服务器应该生成一个有效负载，其中包含足够的信息以供客户端识别冲突的源。<br><br> 冲突最可能发生在对PUT请求的响应中。例如，如果正在使用版本控制，并且将所述的表示包含到与先前(第三方)请求所生成的资源冲突的资源中，源服务器可能会使用409响应来表示它不能完成请求。在这种情况下，响应应尽可能包含有用的信息，以基于修订历史来合并差异。|
| 410 | Gone | 已消失。410(已消失)状态码表明，在源服务器上对目标资源的访问不再可用，并且这种情况可能是永久的。如果源服务器不知道，或者没有任何措施来确定该条件是否永久，则应该使用状态码404(未找到)。 <br><br> 410响应主要是为了协助web维护，通知接收者，资源是故意不可用的，并且服务器所有者希望删除该资源的远程链接引用。这样的情况在有限时间、推广服务和属于个人的资源中是常见的，不再与源服务器的站点相关联。没有必要将所有永久不可用的资源都标记为“gone”或保持标记的长度，这是由服务器所有者决定的。<br><br> 410响应是可缓存的; 除非方法定义或显式的缓存控制(参见[RFC7234](https://tools.ietf.org/html/rfc7234#section-4.2.2)的第4.2.2节)。 |
| 411 | Length Required | 需要数据长度信息。411状态码表示，服务器拒绝接受没有定义 `Content-Length`([RFC7230的3.3.2节](https://tools.ietf.org/html/rfc7230#section-3.3.2)) 的请求。如果在请求消息中添加了包含消息正文长度的有效 `Content-Length` 头字段，则客户端可以重复发起请求。 |
| 413 | Payload Too Large | 负载过大。413状态码表明服务器拒绝处理请求，因为请求有效负载比服务器愿意或能够处理的要大。服务器可能关闭连接以阻止客户端继续请求。 |
| 414 | URI Too Long | URI 超出长度限制。414状态码表示服务器拒绝服务请求，因为请求-目标([RFC7230的5.3节](https://tools.ietf.org/html/rfc7230#section-5.3))超出了服务器能够识别的最大长度。当客户端不当的将一个 POST 请求转化为 GET 请求，并且携带大量查询信息的时候，或者当客户端陷入“黑洞”重定向，亦或者当服务器受到一个试图利用潜在安全漏洞的客户端攻击时，这种罕见的情况才有可能发生。<br><br> 414响应是可缓存的; 除非方法定义或显式的缓存控制(参见[RFC7234](https://tools.ietf.org/html/rfc7234#section-4.2.2)的第4.2.2节)。  |
| 415 | Unsupported Media Type | 不支持的媒体类型。415状态码表示源服务器拒绝服务请求，因为在当前请求方法下，目标资源不支持请求负载的格式。格式问题可能是由于请求的 `Content-Type` 或 `Content-Encoding`，或者是直接检查数据的结果。 |
| 417 | Expectation Failed | 预期失败。417状态码表示，请求的 `Expect` 头字段([第5.1.1节](https://tools.ietf.org/html/rfc7231#section-5.1.1))中给出的期望不能被至少一个入站服务器所满足。|
| 426 | Upgrade Required | 需要升级。426状态码表示，服务器拒绝使用当前协议执行请求，但在客户端升级到另一个不同的协议之后，服务器可能会接受该请求。服务器必须在426响应中发送一个 `Upgrade` 头字段，以表明所需的协议([第6.7条 RFC7230](https://tools.ietf.org/html/rfc7230#section-6.7))。<br><br> 比如：<br>HTTP/1.1 426 Upgrade Required<br>Upgrade: HTTP/3.0 <br>Connection: Upgrade <br>Content-Length: 53 <br>Content-Type: text/plain <br><br> 该服务需要使用HTTP/3.0协议。|

#### 5xx 服务器错误

5xx类状态码表示服务器意识到它有错误或无法执行所请求的方法。除了响应HEAD请求外，服务器都应该发送包含错误情况说明的表示，以及该错误情况是临时的还是永久的。用户代理应该向用户显示任何包含的表示。这些响应代码适用于任何请求方法。


| 状态码 | 描述短语 | 描述 |
| --- | --- | --- |
| 500 | Internal Server Error | 服务器内部错误。500状态码表示服务器遇到了一个意外情况，阻止它完成请求。 |
| 501 | Not Implemented | 未实现。501状态码表示服务器不支持满足请求所需的功能。当服务器不识别请求方法并且不能支持任何资源时，返回501响应是比较合适的。<br><br> 501响应是可缓存的; 除非方法定义或显式的缓存控制(参见[RFC7234](https://tools.ietf.org/html/rfc7234#section-4.2.2)的第4.2.2节)。 |
| 502 | Bad Gateway | 错误网关。充当网关或代理的服务器，从远端服务器接收到了一个无效的请求。 |
| 503 | Service Unavailable | 服务不可用。503状态码表示，由于临时超载或计划维护，服务器目前无法处理请求，这可能在稍后会得到缓解。服务器可以发送 `Retry-After` 头字段([第7.1.3节](https://tools.ietf.org/html/rfc7231#section-7.1.3))，建议客户端在重新尝试请求之前等待适当的时间。<br><br> 注意：503状态代码的存在并不意味着服务器在超载时必须使用它。有些服务器可能会简单地拒绝连接。|
| 504 | Gateway Timeout | 网关超时。504状态码表明，服务器在充当网关或代理时，并没有收到需要访问的上游服务器的及时响应，以完成请求。 |
| 505 | HTTP Version Not Supported | 不支持的 HTTP 版本。505状态码表示服务器不支持或拒绝支持请求消息中使用的主要版本的 HTTP 协议。服务器表示无法或不愿意使用与客户端相同的主要版本(如[RFC7230的第2.6节所述](https://tools.ietf.org/html/rfc7230#section-2.6))来完成请求，而不是使用错误消息。服务器应该为505响应生成一个表示，描述为什么不支持该版本，以及该服务器支持哪些其他协议。 |

> 终于翻译完了初稿（需要继续订正），好累啊......













参考链接

* https://tools.ietf.org/html/rfc7231
* http://www.runoob.com/http/http-status-codes.html
* https://juejin.im/entry/5794c6118ac247005f266b58


